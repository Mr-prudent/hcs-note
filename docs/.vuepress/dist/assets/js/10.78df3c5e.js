(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{373:function(_,v,t){"use strict";t.r(v);var s=t(45),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"第12章-品控与流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第12章-品控与流程"}},[_._v("#")]),_._v(" 第12章 品控与流程")]),_._v(" "),t("p",[_._v("精通CSS不仅意味着能写出可用的标记和样式，还能让代码好阅读、便移植、易维护。")]),_._v(" "),t("h2",{attrs:{id:"_12-1-外部代码质量-调试css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-外部代码质量-调试css"}},[_._v("#")]),_._v(" 12.1 外部代码质量：调试CSS")]),_._v(" "),t("p",[_._v("外部代码质量：")]),_._v(" "),t("ul",[t("li",[_._v("正确性")]),_._v(" "),t("li",[_._v("可用性")]),_._v(" "),t("li",[_._v("健壮性")]),_._v(" "),t("li",[_._v("性能")])]),_._v(" "),t("h4",{attrs:{id:"_12-1-1-浏览器如何解析css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-1-浏览器如何解析css"}},[_._v("#")]),_._v(" 12.1.1 浏览器如何解析CSS")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("解析文件及构建对象模型")]),_._v(" "),t("p",[_._v("浏览器首先会收到一个HTML文件，会将其解析成对象树，即文档对象模型，DOM。")]),_._v(" "),t("p",[_._v("浏览器碰到HTML文件中指向CSS文件链接时，会获取并解析CSS。CSS文件会被浏览器转换为CSS对象模型，CSSOM。不仅是外部文件的CSS，内部style元素或者行内style属性也会被解析。CSSOM也是树形结构的。")]),_._v(" "),t("p",[_._v("每个选择符都会匹配一个DOM节点，然后浏览器基于层叠、继承和特殊性来计算每个DOM节点的样式。")])]),_._v(" "),t("li",[t("p",[_._v("渲染树")]),_._v(" "),t("p",[_._v("渲染页面的下一步是构建另外一个树结构，渲染树。在渲染树中，每个节点表示要渲染到屏幕上的信息。这个结构像DOM，但不完全一样。被隐藏的DOM节点不会出现在这里，"),t("code",[_._v("::after")]),_._v("之类的伪元素会出现，但DOM中没有。除了节点，还会保存滚动块或视口等信息。")])]),_._v(" "),t("li",[t("p",[_._v("布局")]),_._v(" "),t("p",[_._v("接下来计算每个对象的几何属性的这个过程叫布局或重排，浏览器会遍历渲染树，确定每个对象显示在页面上的位置。")])]),_._v(" "),t("li",[t("p",[_._v("绘制、合成与呈现")]),_._v(" "),t("p",[_._v("基于渲染树中的信息，把元素准确地呈现到屏幕上。")]),_._v(" "),t("p",[_._v("确定了每个渲染对象的位置和属性后，浏览器可以计算出在屏幕上的像素数，这个过程叫绘制。")]),_._v(" "),t("p",[_._v("除绘制外，浏览器如果发现最终图像的某一部分不影响页面其他内容的显示，可能把绘制拆分成不同的任务，每个任务负责绘制页面上特定的部分，"),t("strong",[_._v("层")]),_._v("。")]),_._v(" "),t("p",[_._v("有些复杂元素，比如三维变换需要GPU硬件加速。需要先拆分为层，再组合起来，"),t("strong",[_._v("合成")]),_._v("。")])])]),_._v(" "),t("h3",{attrs:{id:"_12-1-2-优化渲染性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-2-优化渲染性能"}},[_._v("#")]),_._v(" 12.1.2 优化渲染性能")]),_._v(" "),t("p",[_._v("如果页面上有了任何变化，那么浏览器都要重复之前的步骤。为保证平滑变化，最好在16ms内完成，60HZ的屏幕。")]),_._v(" "),t("p",[_._v("有些变化几乎不影响性能，比如滚动页面。如果某些变化会导致页面上的样式改变，那么可能会影响性能。")]),_._v(" "),t("p",[_._v("如果通过JavaScript改变了某个元素的width和height，浏览器就需要重新布局、合成和绘制。只改变颜色不需要重新布局，只触发绘制及合成。")]),_._v(" "),t("h2",{attrs:{id:"_12-2-内部代码质量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-内部代码质量"}},[_._v("#")]),_._v(" 12.2 内部代码质量")]),_._v(" "),t("h3",{attrs:{id:"_12-2-1-理解css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-1-理解css"}},[_._v("#")]),_._v(" 12.2.1 理解CSS")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("把CSS当成软件")]),_._v(" "),t("p",[_._v("即使是一个人的项目，也要看成两个人在参与：你和未来的你。")])]),_._v(" "),t("li",[t("p",[_._v("自己引入结构")])])]),_._v(" "),t("blockquote",[t("p",[_._v("限域属性：")]),_._v(" "),t("p",[_._v("带有scoped属性的style可以只作用在内部，只有firefox实现了，但是被移除了。。。vue中发扬光大。")])]),_._v(" "),t("h3",{attrs:{id:"_12-2-2-代码质量的例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-2-代码质量的例子"}},[_._v("#")]),_._v(" 12.2.2 代码质量的例子")]),_._v(" "),t("p",[_._v("ID选择符尽量不使用，可作为js的接入点。")]),_._v(" "),t("h3",{attrs:{id:"_12-2-3-管理层叠"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-3-管理层叠"}},[_._v("#")]),_._v(" 12.2.3 管理层叠")]),_._v(" "),t("p",[_._v("有助于提升代码质量的原则：")]),_._v(" "),t("ul",[t("li",[_._v("以类名为应用样式的主要手段")]),_._v(" "),t("li",[_._v("类名要清晰")]),_._v(" "),t("li",[_._v("拆分出单一规则")]),_._v(" "),t("li",[_._v("不把元素类型和规则绑定在一起")])]),_._v(" "),t("p",[_._v("限制层叠效应")]),_._v(" "),t("h3",{attrs:{id:"_12-2-4-结构命名与css方法论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-4-结构命名与css方法论"}},[_._v("#")]),_._v(" 12.2.4 结构命名与CSS方法论")]),_._v(" "),t("ol",[t("li",[_._v("OOCSS")]),_._v(" "),t("li",[_._v("SMACSS (个人比较喜欢)")]),_._v(" "),t("li",[_._v("BEM")])]),_._v(" "),t("p",[_._v("完结撒花。。。")])])}),[],!1,null,null,null);v.default=a.exports}}]);